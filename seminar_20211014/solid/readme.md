# Что такое SOLID?

Это свод из пяти правил касательно архитектуры проекта.

# Для чего нужны?

* Улучшает дополняемость программы
* Улучшает переиспользуемость
* Улучшает читаемость кода и проекта в целом

# Single-responsibility principle

Kаждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

## Простыми словами

Не мешаем в классе разную логику.

## Пример из википедии

Представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:

* может измениться само содержимое отчёта
* может измениться формат отчёта.

Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. SRP говорит, что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна ответственность. Причина, почему нужно сохранять направленность классов на единственную цель в том, что это делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в процессе составления отчёта — есть большая вероятность, что в негодность придёт код, отвечающий за печать.

## Пример из проекта

Объединять compressor и decompressor в один класс.

## Что улучшает

* Разбивку по логическим сущностям (проще погружаться в проект)
* Убирает неявные зависимости (когда стейт не шерится между разным функционалом, функционал можно менять независимо)
* Улучшает переиспользуемость


# Open–closed principle

Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения.

## Более простыми словами

Проектируем класс так, чтобы не предполагалось в дальнейшем его менять (за исключением багов). Предполагаем, что расширение функциональности будет путем наследования.


# Liskov Substitution Principle

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

## Простыми словами

Если какая-то логика использует базовый не абстрактный класс (его методы, конструкторы, поля), то она не должна ломаться, если на вход придет наследник этого класса.


# Interface segregation principle

Программные сущности не должны зависеть от методов, которые они не используют.

## Простыми словами

Изменение логики любого метода класса не должно ничего ломать в тех местах, где этот метод не используется.


# Dependency inversion principle

* Модули верхних уровней не должны импортировать сущности из модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

## Простыми словами

Классы нужно оборачивать в интерфейсы -- абстрактные обертки с перечислением но без реализации методов.


